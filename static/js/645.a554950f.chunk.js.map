{"version":3,"file":"static/js/645.a554950f.chunk.js","mappings":"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","sources":["articles/ScrambledTitle.jsx","articles/content/TV_head/Article.jsx","../node_modules/use-scramble/src/index.ts"],"sourcesContent":["import { useScramble } from \"use-scramble\";\n\nexport function useScrambledTitle(text) {\n    const { ref, replay } = useScramble({ \n      text: text,\n      speed: 1,\n      overdrive: false,\n      scramble: 10\n    });\n  \n    return <h1 className='scrambled' ref={ref} onClick={replay}></h1>\n}","import '../../default.css';\nimport './theme.css'\nimport React from \"react\";\nimport { useScrambledTitle } from '../../ScrambledTitle';\n\nimport Navbar from '../../../components/navbar/Navbar';\nimport Footer from '../../../components/footer/Footer';\n\nfunction Hi() {\n  const meta = require(\"./meta.json\");\n\n  const date = new Date(meta.date).toLocaleDateString('en-us', {\n    year:\"numeric\", \n    month:\"short\",\n    day:\"2-digit\"\n    }) // \"Jul 2021 Friday\"\n\n\n  return (\n    <div className=\"TV_head\">\n      <Navbar />\n     <article>\n      <div className=\"cover\">\n        {useScrambledTitle(meta.title)}\n        <time>{date}</time>\n        <img className='thumbnail' src={require('./images/mad.gif')}></img>\n        <hr/>\n      </div>\n      <main>  \n        <iframe src=\"https://www.youtube.com/embed/yEIA7uc1x5s\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\n        <p>It all started with me finding this neat video on youtube. I recommend you watch it yourself as I took a lot of advice from it. I downloaded their tutorial files and used them as a reference frequently at the beginning</p>\n\n        <p>I saw a couple of different TV heads previously while doom scrolling, such as the one person from <a href='https://www.youtube.com/watch?v=2HmKYEZgkSY'>Jschlatt's show and tell</a> which has the cool feature of the controls being hidden in the gloves. I tried looking up how to do it but the person who made the cosplay is silent as a partisan so I ended up doing something more boring</p> \n        <h2>The helmet</h2>\n        <p>I happen to own a pretty sweet 3D printer gifted to me from a program I participated in and as a result, decided that printing the case would be the best. One glaring issue arose immediately. That of my lack of skill with 3D modeling. I am gonna be honest. Either the 3D model files weren't in the tutorial zip from the youtube video or I am actually 0/200 vision because I did not find the 3D model they used in the video. That is why I decided to make my own 3D model despite never having seriously done it. I decided to use FreeCAD and my experience has been mixed at best. I don't know enough about CAD to give a real review but the process of trying to do anything outside of making a sketch and then padding it felt like pulling teeth</p>\n        <img className='thumbnail' src={require('./images/big_head.jpg')}></img>\n        <span>Accurate representation of the dimensions of my head</span>\n        <p>The printer bed is not large enough to print anything I can fit my head in, so the helmet was done in many smaller parts. Each side is printed in 4 parts that are later hot glued together using attachment pieces I printed. I also added baby foam around the head holeâ„¢ like in the video so that I don't slice my throat wearing this thing.</p>\n        <h2>The screen</h2>\n        <p>One of the reasons I felt like doing this is because I already have the LED matrix used for the face in the video so it wouldn't be too hard to recreate. That was what I hoped for. Unlucky, because the reason I didn't use the screen for anything is because it wasn't working. I bought a <a href='https://www.adafruit.com/product/2345'>HAT</a> for a Raspberry Pi I own and tried it out a year or so ago maybe. It just didn't work. The screen just unceremoniously goes blank and nothing happens no matter what I tried. It could have been one of several things going wrong. The HAT had to be soldered first so I could have messed something up. I didn't clean flux after soldering and I heard that could cause problems. The HAT or the LED matrix could have just been shipped to me already busted.</p>\n        <img className='thumbnail' src={require('./images/HAT.jpg')}></img>\n        <span>The suspect in question</span>\n        <p>Sick and tired of all this guessing I just bought what Minbitt used in the video. A Matrixportal M4. And it worked great ! Made me wonder what the hell the HAT used a second charger for if the M4 just ran off of a USB. It was very easy to use and saved me much Advil in the process</p>\n        <h2>The software</h2>\n        <p>I tried running Minbitt's code and it worked fine but I wanted more. The controls using an accelerometer were quite inconvenient and I wanted to change it since I planned on going to a con with it. (Also the code was outdated compared to what's in the video I think). I saw that the M4 had Bluetooth Low Power, so I could control the board remotely from my phone. There is a weird problem with the board that causes it to go from 60fps 4k Ultra HD Dolby digital to 1fps if you are connected with BLE and that sucks. I dealt with the problem by ignoring it and just disconnecting from it when I didn't need to change faces</p>\n        <p>The bluefruit BLE app I used has a control pad and it's got 4 arrows and 4 buttons. I used numbers to pick different faces/options and the arrows to pick between 3 different face sets and the options set, where I can control THE GLITCHES</p>\n        <h2>THE GLITCHES</h2>\n        <p>I love glitch visual effects. I think they look cool as hell and I wanted some of that on my TV head. Due to the limited number of buttons and me not wanting to change the effects periodically, I decided to set the helmet to automatic mode. This way different glitches would occur randomly. This would turn off when I manually change faces</p>\n        <p>While making these I also found out the limitations of the Matrixportal M4. These visual effects aren't instant and there is a visible \"scanline\" of sorts which to me just adds to the aesthetic. Some glitches I added are jitter, disappearing rows, random color rows, random palette, full screen garble before reset, and possibly something else I am forgetting. Partially inspired by the boombot screen from <a href='https://www.youtube.com/watch?v=DBDspsbNKRo'>this</a> video</p>\n        <h2>The final product</h2>\n        <img className='thumbnail' src={require('./images/head.png')}></img>\n        <p>I think it looks quite sweet. Overall I am happy with what I got and putting this hunk of junk together was a lot of good experience</p>\n      </main>\n    </article>\n    <Footer />\n    </div>\n  );\n}\n\nexport default Hi;\n","import { useEffect, useRef } from 'react';\n\nfunction getRandomInt(min: number, max: number) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nfunction getRandomChar(range: RangeOrCharCodes) {\n  let rand = 0;\n  if (range.length === 2) {\n    rand = getRandomInt(range[0], range[1]);\n  } else {\n    rand = range[getRandomInt(0, range.length - 1)];\n  }\n\n  return String.fromCharCode(rand);\n}\n\ntype RangeOrCharCodes = {\n  0: number;\n  1: number;\n} & Array<number>;\n\nexport type UseScrambleProps = {\n  /**\n   * When playOnMount is true, the animation will not play the first time a text input is provided.\n   */\n  playOnMount?: boolean;\n  /**\n   * Optional text input\n   */\n  text?: string;\n  /**\n   * 0-1 range that determines the scramble speed. A speed of 1 will redraw 60 times a second. A speed of 0 will pause the animation\n   *\n   * @default 1\n   */\n  speed?: number;\n  /**\n   * The controller will move forward along the text input and scramble more characters, at a pace of `tick` frames. Combined with the `speed` prop, you can control the animation rate\n   *\n   * @default 1\n   */\n  tick?: number;\n  /**\n   * Step forward on every tick\n   *\n   * @default 1\n   */\n  step?: number;\n\n  /**\n   * Chance of scrambling a character, range from 0 to 1, 0 being no chance, and 1 being 100% chance\n   */\n  chance?: number;\n  /**\n   * Randomize `seed` characters at random text positions\n   *\n   * @default 1\n   */\n  seed?: number;\n  /**\n   * How many times to scramble each character?\n   *\n   * @default 1\n   */\n  scramble?: number;\n  /**\n   * Characters to avoid scrambling\n   */\n  ignore?: string[];\n\n  /**\n   * Unicode character range for scrambler.\n   *\n   * If a tupple is provided [60,125], it will randomly choose a unicode character code within that range.\n   *\n   * If the array contains more than two unicode values, it will choose randomly from the array values only.\n   *\n   * To randomize with only two values, you can repeat them in the array [91,93,91,93]\n   *\n   * @default [65,125]\n   */\n  range?: RangeOrCharCodes;\n  /**\n   * Set the animation to overdrive mode, and set the unicode character code to use in the animation\n   */\n  overdrive?: boolean | number;\n  /**\n   * Always start text animation from an empty string\n   *\n   * @default false\n   */\n  overflow?: boolean;\n\n  /**\n   * Callback when animation starts drawing\n   */\n  onAnimationStart?: Function;\n\n  /**\n   * Callback for when the animation finished\n   */\n  onAnimationEnd?: Function;\n\n  /**\n   * onRedraw callback\n   */\n  onAnimationFrame?: (result: string) => void;\n};\n\nexport const useScramble = (props: UseScrambleProps) => {\n  let {\n    playOnMount = true,\n    text = '',\n    speed = 1,\n    seed = 1,\n    step = 1,\n    tick = 1,\n    scramble = 1,\n    chance = 1,\n    overflow = true,\n    range = [65, 125],\n    overdrive = true,\n    onAnimationStart,\n    onAnimationFrame,\n    onAnimationEnd,\n    ignore = [' '],\n  } = props;\n\n  const prefersReducedMotion =\n    typeof window !== \"undefined\"\n      ? window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches\n      : false;\n\n  if (prefersReducedMotion) {\n    step = text.length;\n    chance = 0;\n    overdrive = false;\n  }\n\n  // text node ref\n  const nodeRef = useRef<any>(null);\n\n  // animation frame request\n  const rafRef = useRef<number>(0);\n\n  // compute\n  const elapsedRef = useRef(0);\n  const fpsInterval = 1000 / (60 * speed);\n\n  // scramble step\n  const stepRef = useRef<number>(0);\n\n  // current character index ref\n  const scrambleIndexRef = useRef<number>(0);\n\n  // scramble controller\n  const controlRef = useRef<Array<string | number | null>>([]);\n\n  // overdrive control index\n  const overdriveRef = useRef<number>(0);\n\n  const setIfNotIgnored = (\n    value: string | number | null | number,\n    replace: string | number | null\n  ) => (ignore.includes(`${value}`) ? value : replace);\n\n  // pick random character ahead in the string, and add them to the randomizer\n  const seedForward = () => {\n    if (scrambleIndexRef.current === text.length) return;\n\n    for (var i = 0; i < seed; i++) {\n      const index = getRandomInt(\n        scrambleIndexRef.current,\n        controlRef.current.length\n      );\n      if (\n        typeof controlRef.current[index] !== 'number' &&\n        typeof controlRef.current[index] !== 'undefined'\n      ) {\n        controlRef.current[index] = setIfNotIgnored(\n          controlRef.current[index],\n          getRandomInt(0, 10) >= (1 - chance) * 10 ? scramble || seed : 0\n        );\n      }\n    }\n  };\n\n  // add `step` characters to the randomizer, and increase the scrambleIndexRef pointer\n  const stepForward = () => {\n    for (var i = 0; i < step; i++) {\n      if (scrambleIndexRef.current < text.length) {\n        const currentIndex = scrambleIndexRef.current;\n\n        const shouldScramble = getRandomInt(0, 10) >= (1 - chance) * 10;\n\n        controlRef.current[currentIndex] = setIfNotIgnored(\n          text[scrambleIndexRef.current],\n          shouldScramble\n            ? scramble + getRandomInt(0, Math.ceil(scramble / 2))\n            : 0\n        );\n        scrambleIndexRef.current++;\n      }\n    }\n  };\n\n  const resizeControl = () => {\n    if (text.length < controlRef.current.length) {\n      controlRef.current.pop();\n      controlRef.current.splice(text.length, step);\n    }\n    for (var i = 0; i < step; i++) {\n      if (controlRef.current.length < text.length) {\n        controlRef.current.push(\n          setIfNotIgnored(text[controlRef.current.length + 1], null)\n        );\n      }\n    }\n  };\n\n  const onOverdrive = () => {\n    if (!overdrive) return;\n\n    for (var i = 0; i < step; i++) {\n      const max = Math.max(controlRef.current.length, text.length);\n      if (overdriveRef.current < max) {\n        controlRef.current[overdriveRef.current] = setIfNotIgnored(\n          text[overdriveRef.current],\n          String.fromCharCode(typeof overdrive === 'boolean' ? 95 : overdrive)\n        );\n        overdriveRef.current++;\n      }\n    }\n  };\n\n  const onTick = () => {\n    stepForward();\n    resizeControl();\n    seedForward();\n  };\n\n  /**\n   * Control the animation framerate, from the speed prop\n   *\n   * if speed is 0, stop the animation\n   */\n  const animate = (time: number) => {\n    if (!speed) return;\n\n    rafRef.current = requestAnimationFrame(animate);\n\n    onOverdrive();\n\n    const timeElapsed = time - elapsedRef.current;\n    if (timeElapsed > fpsInterval) {\n      elapsedRef.current = time;\n\n      if (stepRef.current % tick === 0) {\n        onTick();\n      }\n\n      draw();\n    }\n  };\n\n  /**\n   * Redraw text on every animation frame\n   */\n  const draw = () => {\n    if (!nodeRef.current) return;\n\n    let result = '';\n\n    for (var i = 0; i < controlRef.current.length; i++) {\n      const controlValue = controlRef.current[i];\n\n      switch (true) {\n        /**\n         * a positive integer value, get a random character\n         */\n        case typeof controlValue === 'number' && controlValue > 0:\n          result += getRandomChar(range);\n\n          if (i <= scrambleIndexRef.current) {\n            // reduce scramble index only if it's past the scrambleIndexRef\n            controlRef.current[i] = (controlRef.current[i] as number) - 1;\n          }\n          break;\n\n        /**\n         * a string from the previous text\n         */\n        case typeof controlValue === 'string' &&\n          (i >= text.length || i >= scrambleIndexRef.current):\n          result += controlValue;\n          break;\n\n        /**\n         * before scramble index, and equal to the string\n         */\n        case controlValue === text[i] && i < scrambleIndexRef.current:\n          result += text[i];\n          break;\n\n        /**\n         * scramble has finished\n         */\n        case controlValue === 0 && i < text.length:\n          result += text[i];\n          controlRef.current[i] = text[i];\n          break;\n\n        default:\n          result += '';\n      }\n    }\n\n    // set text\n    nodeRef.current.innerHTML = result;\n\n    onAnimationFrame && onAnimationFrame(result);\n\n    /**\n     * Exit if the result is equal to the input\n     *\n     * - Trim control to text length\n     * - fire onAnimationEnd\n     */\n    if (result === text) {\n      controlRef.current.splice(text.length, controlRef.current.length);\n      onAnimationEnd && onAnimationEnd();\n\n      cancelAnimationFrame(rafRef.current);\n    }\n\n    stepRef.current++;\n  };\n\n  /**\n   * Reset scramble controls\n   *\n   * if overflow is true, overflow the control to the an empty array, the size of the text input. This will cause the animation to play from an empty string\n   */\n  const reset = () => {\n    stepRef.current = 0;\n    scrambleIndexRef.current = 0;\n    overdriveRef.current = 0;\n    if (!overflow) {\n      controlRef.current = new Array(text?.length);\n    }\n  };\n\n  /**\n   * Restarts the animation\n   *\n   * Cancels the current animation frame, resets the scramble index and other controls, and requests a new animation\n   */\n  const play = () => {\n    cancelAnimationFrame(rafRef.current);\n    reset();\n    onAnimationStart && onAnimationStart();\n    rafRef.current = requestAnimationFrame(animate);\n  };\n\n  /**\n   * reset scramble when text input is changed\n   */\n  useEffect(() => {\n    reset();\n  }, [text]);\n\n  /**\n   * start or stop animation when text and speed change\n   */\n  useEffect(() => {\n    cancelAnimationFrame(rafRef.current);\n\n    rafRef.current = requestAnimationFrame(animate);\n\n    // cancel raf on unmount\n    return () => {\n      cancelAnimationFrame(rafRef.current);\n    };\n  }, [animate]);\n\n  useEffect(() => {\n    if (!playOnMount) {\n      controlRef.current = text.split('');\n      stepRef.current = text.length;\n      scrambleIndexRef.current = text.length;\n      overdriveRef.current = text.length;\n      draw();\n      cancelAnimationFrame(rafRef.current);\n    }\n  }, []);\n\n  return { ref: nodeRef, replay: play };\n};\n"],"names":["useScrambledTitle","text","_useScramble","useScramble","speed","overdrive","scramble","ref","replay","_jsx","className","onClick","meta","require","date","Date","toLocaleDateString","year","month","day","_jsxs","children","Navbar","title","src","frameborder","allow","allowfullscreen","href","Footer","getRandomInt","min","max","Math","floor","random","getRandomChar","range","rand","length","String","fromCharCode","props","_props$playOnMount","playOnMount","_props$text","_props$speed","_props$seed","seed","_props$step","step","_props$tick","tick","_props$scramble","_props$chance","chance","_props$overflow","overflow","_props$range","_props$overdrive","onAnimationStart","onAnimationFrame","onAnimationEnd","_props$ignore","ignore","window","matchMedia","matches","nodeRef","useRef","rafRef","elapsedRef","fpsInterval","stepRef","scrambleIndexRef","controlRef","overdriveRef","setIfNotIgnored","value","replace","includes","onTick","i","current","currentIndex","shouldScramble","ceil","stepForward","pop","splice","push","resizeControl","index","seedForward","animate","time","requestAnimationFrame","onOverdrive","draw","result","controlValue","innerHTML","cancelAnimationFrame","reset","Array","useEffect","split"],"sourceRoot":""}